
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>树 · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../05-set/set.html" />
    
    
    <link rel="prev" href="../03-stack-queue/stack-queue.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../../">
            
                <a href="../../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    数据结构
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" >
            
                <span>
            
                    
                    基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1.1" data-path="../01-array/array.html">
            
                <a href="../01-array/array.html">
            
                    
                    数组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.2" data-path="../02-linkedlist/linkedlist.html">
            
                <a href="../02-linkedlist/linkedlist.html">
            
                    
                    链表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.3" data-path="../03-stack-queue/stack-queue.html">
            
                <a href="../03-stack-queue/stack-queue.html">
            
                    
                    栈和队列
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.1.4" data-path="tree.html">
            
                <a href="tree.html">
            
                    
                    树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.5" data-path="../05-set/set.html">
            
                <a href="../05-set/set.html">
            
                    
                    集合
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.6" data-path="../06-map/map.html">
            
                <a href="../06-map/map.html">
            
                    
                    哈希表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.1.7" data-path="../07-heap/heap.html">
            
                <a href="../07-heap/heap.html">
            
                    
                    堆
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.2.2" >
            
                <span>
            
                    
                    进阶
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.2.1" data-path="../../advanced/01-union-find/union-find.html">
            
                <a href="../../advanced/01-union-find/union-find.html">
            
                    
                    并查集
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.2" data-path="../../advanced/02-binary-indexed-tree/binary-indexed-tree.html">
            
                <a href="../../advanced/02-binary-indexed-tree/binary-indexed-tree.html">
            
                    
                    树状数组
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.3" data-path="../../advanced/03-segment-tree/segment-tree.html">
            
                <a href="../../advanced/03-segment-tree/segment-tree.html">
            
                    
                    线段树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.4" data-path="../../advanced/04-trie/trie.html">
            
                <a href="../../advanced/04-trie/trie.html">
            
                    
                    字典树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.5" data-path="../../advanced/05-monotone-stack/monotone-stack.html">
            
                <a href="../../advanced/05-monotone-stack/monotone-stack.html">
            
                    
                    单调栈
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2.6" data-path="../../advanced/06-monotone-queue/monotone-queue.html">
            
                <a href="../../advanced/06-monotone-queue/monotone-queue.html">
            
                    
                    单调队列
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    算法
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    基础
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../../../02-algorithm/01-basic/01-sort/sort.html">
            
                <a href="../../../02-algorithm/01-basic/01-sort/sort.html">
            
                    
                    排序
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.2" data-path="../../../02-algorithm/01-basic/02-binary-search/binary-search.html">
            
                <a href="../../../02-algorithm/01-basic/02-binary-search/binary-search.html">
            
                    
                    二分查找
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.3" data-path="../../../02-algorithm/01-basic/03-two-pointer/two-pointer.html">
            
                <a href="../../../02-algorithm/01-basic/03-two-pointer/two-pointer.html">
            
                    
                    双指针
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.4" data-path="../../../02-algorithm/01-basic/04-sliding-window/sliding-window.html">
            
                <a href="../../../02-algorithm/01-basic/04-sliding-window/sliding-window.html">
            
                    
                    滑动窗口
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.5" data-path="../../../02-algorithm/01-basic/05-divide-and-conquer/divide-and-conquer.html">
            
                <a href="../../../02-algorithm/01-basic/05-divide-and-conquer/divide-and-conquer.html">
            
                    
                    分治
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.6" data-path="../../../02-algorithm/01-basic/06-backtracking/backtracking.html">
            
                <a href="../../../02-algorithm/01-basic/06-backtracking/backtracking.html">
            
                    
                    回溯
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.7" data-path="../../../02-algorithm/01-basic/07-depth-first-search/dfs.html">
            
                <a href="../../../02-algorithm/01-basic/07-depth-first-search/dfs.html">
            
                    
                    深度优先搜索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.8" data-path="../../../02-algorithm/01-basic/08-breadth-first-search/bfs.html">
            
                <a href="../../../02-algorithm/01-basic/08-breadth-first-search/bfs.html">
            
                    
                    宽度优先搜索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.1.9" data-path="../../../02-algorithm/01-basic/08-greedy/greedy.html">
            
                <a href="../../../02-algorithm/01-basic/08-greedy/greedy.html">
            
                    
                    贪心
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2" >
            
                <span>
            
                    
                    进阶
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1" >
            
                <span>
            
                    
                    动态规划
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.1.1" data-path="../../../02-algorithm/02-advanced/01-dp/01-线性/linear.html">
            
                <a href="../../../02-algorithm/02-advanced/01-dp/01-线性/linear.html">
            
                    
                    线性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.1.2" data-path="../../../02-algorithm/02-advanced/01-dp/02-区间/interval.html">
            
                <a href="../../../02-algorithm/02-advanced/01-dp/02-区间/interval.html">
            
                    
                    区间
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2.2" >
            
                <span>
            
                    
                    图论
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.2.1" data-path="../../../02-algorithm/02-advanced/02-graph/01-connected/connected.html">
            
                <a href="../../../02-algorithm/02-advanced/02-graph/01-connected/connected.html">
            
                    
                    连通性
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.2.2" data-path="../../../02-algorithm/02-advanced/02-graph/02-topological/topological.html">
            
                <a href="../../../02-algorithm/02-advanced/02-graph/02-topological/topological.html">
            
                    
                    拓扑排序
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2.3" >
            
                <span>
            
                    
                    字符串
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.3.1" data-path="../../../02-algorithm/02-advanced/03-string/01-kmp/kmp.html">
            
                <a href="../../../02-algorithm/02-advanced/03-string/01-kmp/kmp.html">
            
                    
                    KMP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.3.2" data-path="../../../02-algorithm/02-advanced/03-string/02-manacher/manacher.html">
            
                <a href="../../../02-algorithm/02-advanced/03-string/02-manacher/manacher.html">
            
                    
                    Manacher
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3.2.4" >
            
                <span>
            
                    
                    数学
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.2.4.1" data-path="../../../02-algorithm/02-advanced/04-math/01-big-num/big-num.html">
            
                <a href="../../../02-algorithm/02-advanced/04-math/01-big-num/big-num.html">
            
                    
                    大数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4.2" data-path="../../../02-algorithm/02-advanced/04-math/02-quick-pow/quick-pow.html">
            
                <a href="../../../02-algorithm/02-advanced/04-math/02-quick-pow/quick-pow.html">
            
                    
                    快速幂
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2.4.3" data-path="../../../02-algorithm/02-advanced/04-math/03-number-theory/number-theory.html">
            
                <a href="../../../02-algorithm/02-advanced/04-math/03-number-theory/number-theory.html">
            
                    
                    数论
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../.." >树</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="&#x6811;">&#x6811;</h1>
<blockquote>
<p>&#x5237;&#x9898;&#x5148;&#x5237;&#x4E8C;&#x53C9;&#x6811;</p>
</blockquote>
<h2 id="&#x5E38;&#x7528;&#x64CD;&#x4F5C;">&#x5E38;&#x7528;&#x64CD;&#x4F5C;</h2>
<h3 id="1-&#x5EFA;&#x6811;&#x3001;&#x8C03;&#x8BD5;">1. &#x5EFA;&#x6811;&#x3001;&#x8C03;&#x8BD5;</h3>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>{
        <span class="hljs-keyword">public</span> E e;
        <span class="hljs-keyword">public</span> Node left, right;

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span></span>{
            <span class="hljs-keyword">this</span>.e = e;
            left = <span class="hljs-keyword">null</span>;
            right = <span class="hljs-keyword">null</span>;
        }
    }

    <span class="hljs-keyword">private</span> Node root;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BST</span><span class="hljs-params">()</span></span>{
        root = <span class="hljs-keyword">null</span>;
        size = <span class="hljs-number">0</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BST</span><span class="hljs-params">(E[] array)</span></span>{
        root = generateAVL(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);
        size = array.length;
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">generateAVL</span><span class="hljs-params">(E[] array, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span>{
        <span class="hljs-keyword">if</span>(l &gt; r){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;
        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(array[mid]);
        node.left = generateAVL(array, l, mid - <span class="hljs-number">1</span>);
        node.right = generateAVL(array, mid + <span class="hljs-number">1</span>, r);
        <span class="hljs-keyword">return</span> node;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> size;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>{
        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;
    }


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>{
        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();
        generateBSTString(root, <span class="hljs-number">0</span>, res);
        <span class="hljs-keyword">return</span> res.toString();
    }

    <span class="hljs-comment">// &#x751F;&#x6210;&#x4EE5;node&#x4E3A;&#x6839;&#x8282;&#x70B9;&#xFF0C;&#x6DF1;&#x5EA6;&#x4E3A;depth&#x7684;&#x63CF;&#x8FF0;&#x4E8C;&#x53C9;&#x6811;&#x7684;&#x5B57;&#x7B26;&#x4E32;</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generateBSTString</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> depth, StringBuilder res)</span></span>{

        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>){
            res.append(generateDepthString(depth) + <span class="hljs-string">&quot;null\n&quot;</span>);
            <span class="hljs-keyword">return</span>;
        }

        res.append(generateDepthString(depth) + node.e +<span class="hljs-string">&quot;\n&quot;</span>);
        generateBSTString(node.left, depth + <span class="hljs-number">1</span>, res);
        generateBSTString(node.right, depth + <span class="hljs-number">1</span>, res);
    }

    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateDepthString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> depth)</span></span>{
        StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; depth ; i ++)
            res.append(<span class="hljs-string">&quot;--&quot;</span>);
        <span class="hljs-keyword">return</span> res.toString();
    }
}
</code></pre>
<h3 id="2-&#x9012;&#x5F52;&#x904D;&#x5386;">2. &#x9012;&#x5F52;&#x904D;&#x5386;</h3>
<p>&#x524D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
        <span class="hljs-comment">// write your code here</span>
        preOrder(root.left);
        preOrder(root.right);
    }
}
</code></pre>
<p>&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
        inOrder(root.left);
        <span class="hljs-comment">// write your code here</span>
        inOrder(root.right);
    }
}
</code></pre>
<p>&#x540E;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root != <span class="hljs-keyword">null</span>) {
        postOrder(root.left);
        postOrder(root.right);
        <span class="hljs-comment">// write your code here</span>
    }
}
</code></pre>
<h3 id="3-&#x975E;&#x9012;&#x5F52;&#x904D;&#x5386;">3. &#x975E;&#x9012;&#x5F52;&#x904D;&#x5386;</h3>
<p>&#x524D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    TreeNode p = root;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> || !stack.isEmpty()) {
        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// write your code here</span>
            stack.push(p);
            p = p.left;
        }
        p = stack.pop();
        p = p.right;
    }
}
</code></pre>
<p>&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    TreeNode p = root;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> || !stack.isEmpty()) {
        <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) {
            stack.push(p);
            p = p.left;
        }
        p = stack.pop();
        <span class="hljs-comment">// write your code here</span>
        p = p.right;
    }
}
</code></pre>
<p>&#x540E;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-comment">// &#x7B2C;&#x4E00;&#x79CD;&#x53CC;&#x6808;</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    Deque&lt;TreeNode&gt; stack1 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    Deque&lt;TreeNode&gt; stack2 = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    TreeNode p = root;
    stack1.push(root);
    <span class="hljs-keyword">while</span> (!stack1.isEmpty()) {
        TreeNode node = stack1.pop();
        stack2.push(node);
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) {
            stack1.push(node.left);
        }
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) {
            stack1.push(node.right);
        }
    }
    <span class="hljs-keyword">while</span> (!stack2.isEmpty()) {
        <span class="hljs-comment">// write your code here</span>
    }
}

<span class="hljs-comment">// &#x7B2C;&#x4E8C;&#x79CD;pre</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();
    stack.push(root);
    TreeNode pre = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">while</span> (!stack.isEmpty()) {
        TreeNode node = stack.peek();
        <span class="hljs-keyword">if</span> ((node.left == <span class="hljs-keyword">null</span> &amp;&amp; node.right == <span class="hljs-keyword">null</span>) || (pre != <span class="hljs-keyword">null</span> &amp;&amp; (pre == node.left || pre == node.right))) {
            <span class="hljs-comment">// write your code here</span>
            stack.pop();
            pre = node;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) {
                stack.push(node.right);
            }
              <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) {
                stack.push(node.left);
            }
        }
    }
}
</code></pre>
<p>&#x5C42;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span>;
    }
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
    queue.offer(root);
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) {
        <span class="hljs-keyword">int</span> sz = queue.size();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) {
            TreeNode node = queue.poll();
            <span class="hljs-comment">// write your code here</span>
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-keyword">null</span>) {
                queue.offer(node.left);
            }
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-keyword">null</span>) {
                queue.offer(node.right);
            }
        }
    }
}
</code></pre>
<h3 id="4-morris&#x904D;&#x5386;">4. Morris&#x904D;&#x5386;</h3>
<p>&#x524D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    TreeNode cur = root, pre = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">for</span> (; cur != <span class="hljs-keyword">null</span>;) {
        <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) {
            pre = cur.left;
            <span class="hljs-comment">// &#x5BFB;&#x627E;&#x524D;&#x9A71;&#x7ED3;&#x70B9;</span>
            <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-keyword">null</span> &amp;&amp; pre.right != cur) {
                pre = pre.right;
            }
            <span class="hljs-keyword">if</span> (pre.right == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">// write your code here</span>
                pre.right = cur;
                cur = cur.left;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// &#x5220;&#x9664;&#x7EBF;&#x7D22;</span>
                pre.right = <span class="hljs-keyword">null</span>;
                cur = cur.right;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// write your code here</span>
            cur = cur.right;
        }
    }
}
</code></pre>
<p>&#x4E2D;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    TreeNode cur = root, pre = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">for</span> (; cur != <span class="hljs-keyword">null</span>;) {
        <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) {
            pre = cur.left;
            <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-keyword">null</span> &amp;&amp; pre.right != cur) {
                pre = pre.right;
            }
            <span class="hljs-keyword">if</span> (pre.right == <span class="hljs-keyword">null</span>) {
                pre.right = cur;
                cur = cur.left;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// write your code here</span>
                pre.right = <span class="hljs-keyword">null</span>;
                cur = cur.right;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// write your code here</span>
            cur = cur.right;
        }
    }
}
</code></pre>
<p>&#x540E;&#x5E8F;&#x904D;&#x5386;&#xFF1A;</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span> </span>{
    TreeNode dummy = <span class="hljs-keyword">new</span> TreeNode(-<span class="hljs-number">1</span>);
    dummy.left = root;
    TreeNode cur = dummy, pre = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">for</span> (; cur != <span class="hljs-keyword">null</span>;) {
        <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) {
            pre = cur.left;
            <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-keyword">null</span> &amp;&amp; pre.right != cur) {
                pre = pre.right;   
            }
            <span class="hljs-keyword">if</span> (pre.right == <span class="hljs-keyword">null</span>) {
                pre.right = cur;
                cur = cur.left;
            } <span class="hljs-keyword">else</span> {
                reverse(cur.left, pre);
                print(pre, cur.left);
                reverse(pre, cur.left);
                pre.right = <span class="hljs-keyword">null</span>;
                cur = cur.right;
            }

        } <span class="hljs-keyword">else</span> {
            cur = cur.right;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(TreeNode from, TreeNode to)</span> </span>{
    <span class="hljs-keyword">for</span> (;;from = from.right) {
        <span class="hljs-comment">// write your code here</span>
        <span class="hljs-keyword">if</span> (from == to) {
            <span class="hljs-keyword">break</span>;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(TreeNode from, TreeNode to)</span> </span>{
    <span class="hljs-keyword">if</span> (from == to) {
        <span class="hljs-keyword">return</span>;
    }
    TreeNode x = from, y = from.right, z= <span class="hljs-keyword">null</span>;
    x.right = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">for</span> (;;) {
        z = y.right;
        y.right = x;
        x = y;
        <span class="hljs-keyword">if</span> (y == to) {
            <span class="hljs-keyword">break</span>;
        }
        y = z;
    }
}
</code></pre>
<h2 id="&#x9898;&#x76EE;">&#x9898;&#x76EE;</h2>
<h3 id="105-construct-binary-tree-from-preorder-and-inorder-traversal">105. construct-binary-tree-from-preorder-and-inorder-traversal</h3>
<hr>
<p><strong>Description:</strong></p>
<p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong>
You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
</code></pre><p>Return the following binary tree:</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/?currentPage=1&amp;orderBy=most_votes&amp;query=" target="_blank">Discussion</a> | <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/" target="_blank">Solution</a></p>
<p><strong>Code:</strong></p>
<pre><code class="lang-java"><span class="hljs-keyword">import</span> java.util.Arrays;

<span class="hljs-comment">/*
 * @lc app=leetcode id=105 lang=java
 *
 * [105] Construct Binary Tree from Preorder and Inorder Traversal
 */</span>

<span class="hljs-comment">// @lc code=start</span>
<span class="hljs-comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>{
        <span class="hljs-keyword">return</span> helper(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, preorder, inorder);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>{
        <span class="hljs-keyword">if</span> (preStart &gt; preorder.length - <span class="hljs-number">1</span> || inStart &gt; inEnd) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        TreeNode root = <span class="hljs-keyword">new</span> TreeNode(preorder[preStart]);
        <span class="hljs-keyword">int</span> inIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// Index of current root in inorder</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inStart; i &lt;= inEnd; i++) {
            <span class="hljs-keyword">if</span> (inorder[i] == root.val) {
                inIndex = i;
            }
        }
        root.left = helper(preStart + <span class="hljs-number">1</span>, inStart, inIndex - <span class="hljs-number">1</span>, preorder, inorder);
        root.right = helper(preStart + inIndex - inStart + <span class="hljs-number">1</span>, inIndex + <span class="hljs-number">1</span>, inEnd, preorder, inorder);
        <span class="hljs-keyword">return</span> root;
    }
}
<span class="hljs-comment">// @lc code=end</span>
</code></pre>
<h3 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">106. construct-binary-tree-from-inorder-and-postorder-traversal</h3>
<hr>
<p><strong>Description:</strong></p>
<p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><strong>Note:</strong>
You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
</code></pre><p>Return the following binary tree:</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/discuss/?currentPage=1&amp;orderBy=most_votes&amp;query=" target="_blank">Discussion</a> | <a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solution/" target="_blank">Solution</a></p>
<p><strong>Code:</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">/*
 * @lc app=leetcode id=106 lang=java
 *
 * [106] Construct Binary Tree from Inorder and Postorder Traversal
 */</span>

<span class="hljs-comment">// @lc code=start</span>
<span class="hljs-comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>{
        <span class="hljs-keyword">return</span> build(postorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, inorder, postorder);
    }
    <span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> postEnd, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd, <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span>[] postorder)</span> </span>{
        <span class="hljs-keyword">if</span> (postEnd &lt; <span class="hljs-number">0</span> || inStart &gt; inEnd) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        TreeNode node = <span class="hljs-keyword">new</span> TreeNode(postorder[postEnd]);
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inStart; i &lt;= inEnd; i++) {
            <span class="hljs-keyword">if</span> (inorder[i] == node.val) {
                index = i;
            }
        }
        node.left = build(postEnd - <span class="hljs-number">1</span> - inEnd + index, inStart, index - <span class="hljs-number">1</span>, inorder, postorder);
        node.right = build(postEnd - <span class="hljs-number">1</span>, index + <span class="hljs-number">1</span>, inEnd, inorder, postorder);
        <span class="hljs-keyword">return</span> node;
    }
}
<span class="hljs-comment">// @lc code=end</span>
</code></pre>
<h3 id="117-populating-next-right-pointers-in-each-node-ii">117. populating-next-right-pointers-in-each-node-ii</h3>
<hr>
<p><strong>Description:</strong></p>
<p>Given a binary tree</p>
<pre><code>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><strong>Follow up:</strong></p>
<ul>
<li>You may only use constant extra space.</li>
<li>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="img"></p>
<pre><code>Input: root = [1,2,3,4,5,null,7]
Output: [1,#,2,3,#,4,5,7,#]
Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &apos;#&apos; signifying the end of each level.
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the given tree is less than <code>6000</code>.</li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
<p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/?currentPage=1&amp;orderBy=most_votes&amp;query=" target="_blank">Discussion</a> | <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/solution/" target="_blank">Solution</a></p>
<p><strong>Code:</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">/*
 * @lc app=leetcode id=117 lang=java
 *
 * [117] Populating Next Right Pointers in Each Node II
 */</span>

<span class="hljs-comment">// @lc code=start</span>
<span class="hljs-comment">/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>{
        Node head = <span class="hljs-keyword">null</span>, pre = <span class="hljs-keyword">null</span>, cur = root;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) {
                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) {
                        pre.next = cur.left;
                    } <span class="hljs-keyword">else</span> {
                        head = cur.left;
                    }
                    pre = cur.left;
                }
                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-keyword">null</span>) {
                    <span class="hljs-keyword">if</span> (pre != <span class="hljs-keyword">null</span>) {
                        pre.next = cur.right;
                    } <span class="hljs-keyword">else</span> {
                        head = cur.right;
                    }
                    pre = cur.right;
                }
                cur = cur.next;
            }
            cur = head;
            head = <span class="hljs-keyword">null</span>;
            pre = <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">return</span> root;
    }
}
<span class="hljs-comment">// @lc code=end</span>
</code></pre>
<h3 id="99-recover-binary-search-tree">99. recover-binary-search-tree</h3>
<hr>
<p><strong>Description:</strong></p>
<p>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: [1,3,null,null,2]

   1
  /
 3
  \
   2

Output: [3,1,null,null,2]

   3
  /
 1
  \
   2
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

Output: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
</code></pre><p><strong>Follow up:</strong></p>
<ul>
<li>A solution using O(<em>n</em>) space is pretty straight forward.</li>
<li>Could you devise a constant space solution?</li>
</ul>
<p><strong>Code:</strong></p>
<pre><code class="lang-java"><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode root)</span> </span>{
        TreeNode first = <span class="hljs-keyword">null</span>, second = <span class="hljs-keyword">null</span>, p = <span class="hljs-keyword">null</span>;
        TreeNode cur = root, pre = <span class="hljs-keyword">null</span>;
        <span class="hljs-keyword">for</span> (; cur != <span class="hljs-keyword">null</span>;) {
            <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-keyword">null</span>) {
                pre = cur.left;
                <span class="hljs-keyword">while</span> (pre.right != <span class="hljs-keyword">null</span> &amp;&amp; pre.right != cur) {
                    pre = pre.right;
                }
                <span class="hljs-keyword">if</span> (pre.right == <span class="hljs-keyword">null</span>) {
                    pre.right = cur;
                    cur = cur.left;
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.val &gt; cur.val) {
                        <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>) {
                            first = p;
                            second = cur;
                        }
                        <span class="hljs-keyword">else</span> {
                            second = cur;
                        }
                    }
                    p = cur;

                    pre.right = <span class="hljs-keyword">null</span>;
                    cur = cur.right;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.val &gt; cur.val) {
                    <span class="hljs-keyword">if</span> (first == <span class="hljs-keyword">null</span>) {
                        first = p;
                        second = cur;
                    }
                    <span class="hljs-keyword">else</span> {
                        second = cur;
                    }
                }
                p = cur;

                cur = cur.right;
            }
        }
        <span class="hljs-keyword">int</span> tmp = first.val;
        first.val = second.val;
        second.val = tmp;
    }
}
</code></pre>
<h2 id="&#x53C2;&#x8003;">&#x53C2;&#x8003;</h2>
<p><a href="https://spground.github.io/2018/01/27/Morris%20binary-tree%20traverse/" target="_blank">Morris</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../03-stack-queue/stack-queue.html" class="navigation navigation-prev " aria-label="Previous page: 栈和队列">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../05-set/set.html" class="navigation navigation-next " aria-label="Next page: 集合">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"树","level":"1.2.1.4","depth":3,"next":{"title":"集合","level":"1.2.1.5","depth":3,"path":"01-data-structrue/basic/05-set/set.md","ref":"01-data-structrue/basic/05-set/set.md","articles":[]},"previous":{"title":"栈和队列","level":"1.2.1.3","depth":3,"path":"01-data-structrue/basic/03-stack-queue/stack-queue.md","ref":"01-data-structrue/basic/03-stack-queue/stack-queue.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"01-data-structrue/basic/04-tree/tree.md","mtime":"2020-05-27T15:53:07.000Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-07-17T08:53:22.954Z"},"basePath":"../../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../../gitbook/gitbook.js"></script>
    <script src="../../../gitbook/theme.js"></script>
    
        
        <script src="../../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

